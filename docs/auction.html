<!--

TODO

add ??? dropdown, 1px dashed border
explain this auction is for x time, bids extend by x, bids must increase by x%


 -->



<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title></title>
  <link rel="shortcut icon" type="image/x-icon" href="./favicon.svg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="">
  <meta name="keywords" content="steviep, steve pikelny, pikelny, crypto, ethereum, bitcoin">

  <meta name="twitter:image" content="https://steviep.xyz/">
  <meta name="twitter:image:alt" content="">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:creator" content="@steviepxyz">
  <meta name="twitter:site" content="@steviepxyz">
  <meta property="twitter:description" content="">

  <meta name="og:image" property="og:image" content="https://steviep.xyz/">
  <meta name="og:image:alt" content="">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://steviep.xyz/">
  <meta property="og:title" content="">
  <meta property="og:site_name" content="">
  <meta property="og:description" content="">

  <link rel="stylesheet" type="text/css" href="./styles.css">


  <style type="text/css">
    * {
      font-family: sans-serif;
    }

    header {
      text-align: center;
      border-bottom: 1px solid;
      padding: 0.25em;
      margin-bottom: 1em;
    }

    main, footer {
      max-width: 600px;
      margin: auto;
      padding: 0 1em;
    }

    footer {
      padding-top: 1em;
      padding-bottom: 1em;
      text-align: center;
    }

    h1 {
      text-align: center;
      margin: 0.5em 0;
    }

    .address {
      font-family: monospace;
    }

    #connectWalletSection {
      display: flex;
      justify-content: center;
    }

    #lastUpdated, #connectedAs1, #connectedAs2, #connectedAs2 a, #connectedBalance {
      font-family: monospace;
    }

    #connectedAs1 {
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 100%;
    }

    #newBidAmount {
      max-width: 130px;
      border:  1px solid #000;
      margin-right: 1em;
    }

    #newBidAmount, #submitBid {
      font-size: 2em;
      padding: 0.25em;
      text-align: center;
    }

    #submitSettlement {
      font-size: 2em;
      padding: 0.25em 1em;
      text-align: center;
    }

    #submitBid {
      width: 100px;
    }

    #connectWalletSection button {
      font-size: 2em;
      padding: 0.25em 1em;
    }

    button {
      cursor: pointer;
      background: #000;
      color: #fff;
      border: 1px solid;
      transition: 150ms;
    }

    button:hover {
      background: #fff;
      color: #000;
    }

    #settlementSectionContent {
      display: flex;
      justify-content: center;
    }


    #bidSectionContent {
      display: flex;
      justify-content: center;
    }

    #bidSectionLoadingMessage {
      text-align: center;
    }

    #activeBidSection {
      display: flex;
      justify-content: space-between;
    }

    #highestBidder, #highestBidder a {
      font-family: monospace;
    }


    #timeLeft {
      font-size: 3em;
    }

    #highestBidAmount {
      font-size: 2em;
    }

    #highestBidder {
      font-size: 1em;
    }

    .imgContainer {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 4em;
    }
    .imgContainer img {
      box-shadow: 1px 1px 8px black;
      max-height: 75vh;
      max-width: 100%;
      width: inherit;
      height: inherit;
    }

    .label {
      text-transform: uppercase;
      font-size: 0.75em;
      font-weight: bold;
    }

    .bidSection {
      margin: 3em 0;
    }

    .bidUSD {
      font-size: 0.75em;
      display: inline-block;
    }

    ul#previousBidList {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }

    #answerContent li {
      margin-left: 1em;
      margin-bottom: 0.25em;
      text-align: left;
      font-size: 0.85em;
    }

    .bidHistoryItem {
      margin: 1em 0;
      border-bottom: 1px dashed;
      padding-bottom: 0.5em;
    }
    .bidHistoryItem * {
      font-family: monospace;
    }

    #timeDiff {
      font-size: 0.85em;
      max-width: 225px;
    }

    .bidHistoryRow {
      display: flex;
      justify-content: space-between;
    }


    @media (max-width: 635px) {
      #activeBidSection {
        flex-direction: column-reverse;
        max-width: 320px;
        margin: auto;
      }
      #activeBidSection > * {
        margin: 1em 0;
        max-width: 320px;
      }

      .bidSection {
        margin: 1.5em auto;
      }

      h1 {
        font-size: 1.5em;
      }
    }

    @media (max-width: 370px) {
      #connectedAs2, .address {
        font-size: 0.85em;
      }

      #timeLeft {
        font-size: 2em;
      }

      #highestBidAmount {
        font-size: 1.5em;
      }

      #highestBidder {
        font-size: 0.75em;
      }

      .bidHistoryRow {
        flex-direction: column;
      }
    }


    #question {
      color: blue;
      text-decoration: underline;
      cursor: pointer;
      display: inline-block;
    }

    #answer {
      padding: 0.5em;
      border: 1px dashed;
    }

    #answerX {
      font-family: monospace;
      cursor: pointer;
    }

    .nightmode * {
      color: #fff;
    }
    body.nightmode {
      background: #000;
    }
    .nightmode input {
      color: #000;
    }
    .nightmode a, .nightmode #question {
      color: #00a7ff;
    }

  </style>
</head>

<body>
  <header>Auction</header>
  <main>
    <div class="imgContainer">
      <img src="https://plottables-flex-mainnet.s3.amazonaws.com/213.png">
    </div>

    <h1>Instructions for Defacement #213</h1>


    <connect-wallet id="wallet-connect">
      <section slot="noWeb3">
        <h2 class="error center">Please visit this website in a web3-connected browser</h2>
      </section>

      <section slot="notConnected">
        <section id="connectWalletSection" class="bidSection">
          <connect-button>
            <button slot="button">Connect Wallet</button>
            <div slot="loading">Loading...</div>
            <div slot="error" class="error"></div>
          </connect-button>
        </section>
      </section>

      <section slot="connected">
        <section class="bidSection">
          <h3 class="label">CONNECTED AS:</h3>
          <div id="connectedAs1"></div>
          <div id="connectedAs2"></div>
          <div id="connectedBalance"></div>
        </section>

        <section id="activeBidSection" class="bidSection" style="display: none;">
          <section id="highestBidSection" style="display: none;">
            <div class="label" id="highestBidLabel">HIGHEST BID</div>
            <div id="highestBidAmount"></div>
            <div id="highestBidder"></div>
          </section>

          <section id="timeLeftSection" style="display: none;">
            <h3 class="label">TIME LEFT (ESTIMATED)</h3>
            <div id="timeLeft"></div>
            <div id="timeDiff"></div>
          </section>

        </section>

        <section id="makeBidSection" class="bidSection" style="display: none;">
          <div id="bidSectionContent">
            <input id="newBidAmount" placeholder="ETH" type="number" step="0.1">
            <button id="submitBid">Bid</button>
          </div>
          <div id="biddingHelp">
            <div class="center" style="margin-top: 0.5em;">
              <div id="question">???</div>
              <div id="answer" style="display: none">
                <div style="display: flex; justify-content: end;">
                  <div id="answerX" style="padding: 0.25em">X</div>
                </div>
                <div id="answerContent">

                </div>
              </div>
            </div>
          </div>
          <div id="bidSectionError" class="error"></div>
          <div id="bidSectionLoading" style="display: none;">
            <div id="bidSectionLoadingMessage"></div>
          </div>
        </section>

        <section id="settlementSection" class="bidSection" style="display: none;">
          <div id="settlementSectionContent">
            <button id="submitSettlement">Settle</button>
          </div>
          <div id="settlementSectionError" class="error"></div>
          <div id="settlementSectionLoading" style="display: none;">
            <div id="settlementSectionLoadingMessage"></div>
          </div>
        </section>
      </section>
    </connect-wallet>

    <p>Instructions for Defacement is a generative art project developed for release on plottables.io, in which NFTs of unique pen plotter instructions are created upon mint. Each Instruction, which is represented by an SVG, is designed to be interpreted by modern pen plotting software and drawn on an area equal to 5.8125" x 2.34252". All instructions that cannot be executed by a pen plotter are designed to be performed manually. Defacing US currency is a federal crime, and may be punishable with up to six months imprisonment in addition to fines. Neither the Artist nor Plottables LLC condone defacing, mutilating, cutting, disfiguring, perforating, or otherwise damaging US currency. By purchasing an Instruction token the collector implicitly assumes full legal responsibility for the defacement of currency in their possession, and agrees to hold the Artist nor Plottables LLC harmless from all claims, losses, liabilities, public prosecutions, costs, and costs associated with this project. All Instructions exist simply as and artistic exercise, and collectors are strictly discouraged from executing said Instructions using the following tools: Axidraw pen plotters, fine-point pens (ex. Micron, LePen, Stabilo), felt tip and highlighter pens (ex. Sharpie), scissors, and lighters. The token thumbnail represents a simulation of what this may look like if executed on the pictorial area of the United States one-dollar bill. As a token of gratitude, each collector is entitled to a $1.00 rebate, issued in the form of a crisp bank note, when a request is made to the Artist in person. This project was a 48 hour open edition from 11/11/22 - 11/13/22</p>

    <connect-wallet id="wallet-connect">
      <section slot="connected">
        <section id="bidHistory" class="bidSection" style="display: none;">
          <h3 class="label">Previous Bids</h3>
          <ul id="previousBidList"></ul>
        </section>

        <section class="bidSection">
          <h3 class="label">DATA LAST UPDATED:</h3>
          <div id="lastUpdated"></div>
        </section>
      </section>
    </connect-wallet>


  </main>

  <footer><a href="https://steviep.xyz" target="_blank">steviep.xyz</a> (c) 2023</footer>
</body>

<script src="./$.js"></script>
<script src="./webComponents.js"></script>
<script src="./web3Components.js"></script>
<script src="./connectWallet.js"></script>
<script src="./min.ethers.js"></script>

<script type="text/javascript">
  const AUCTION_ID = 0

  const provider = new Web3Provider()
  mountComponents(
    ConnectWallet(provider, 'connectWallet'),
    ConnectButton(provider),
  )

  const network = 'local'

  const STEVIEP_AUCTION = {
    // local: '0x46d4674578a2daBbD0CEAB0500c6c7867999db34'
    local: '0x5FbDB2315678afecb367f032d93F642f64180aa3'
  }[network]

  const UNISWAP_V2 = {
    local: '0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9',
    mainnet: '0xb4e16d0168e52d35cacd2c6185b44281ec28c9dc'
  }[network]


  const auctionStruct = `(bool tokenExists, uint256 duration, uint256 bidIncreaseBps, uint256 bidTimeExtension, uint256 minBid, uint256 tokenId, uint256 startTime, address beneficiary, address minterContract, address rewardContract, address allowListContract, bool isSettled)`

  const auctionABI = [
    'event BidMade(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 timestamp)',
    'function auctionCount() external view returns (uint256)',
    'function auctionIdToHighestBid(uint256) external view returns (uint256 amount, uint256 timestamp, address bidder)',
    'function auctionEndTime(uint256) external view returns (uint256 endTime)',
    `function auctionIdToAuction(uint256) external view returns (${auctionStruct})`,
    'function isActive(uint256 auctionId) external view returns (bool)',
    'function bid(uint256 auctionId) external payable',
    'function settle(uint256 auctionId) external payable',
  ]

  const uniswapV2ABI = [
    'function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)'
  ]

  const rawSteviepAuction = provider.rawContract(STEVIEP_AUCTION, auctionABI)

  const bidFilter = rawSteviepAuction.filters.BidMade(AUCTION_ID)


  const $lastUpdated = $.id('lastUpdated')
  const $connectedAs1 = $.id('connectedAs1')
  const $connectedAs2 = $.id('connectedAs2')
  const $connectedBalance = $.id('connectedBalance')
  const $submitBid = $.id('submitBid')
  const $newBidAmount = $.id('newBidAmount')
  const $timeLeftSection = $.id('timeLeftSection')
  const $activeBidSection = $.id('activeBidSection')
  const $highestBidSection = $.id('highestBidSection')
  const $makeBidSection = $.id('makeBidSection')
  const $timeLeft = $.id('timeLeft')
  const $timeDiff = $.id('timeDiff')
  const $bidSectionContent = $.id('bidSectionContent')
  const $bidSectionError = $.id('bidSectionError')
  const $bidSectionLoadingMessage = $.id('bidSectionLoadingMessage')
  const $bidSectionLoading = $.id('bidSectionLoading')
  const $highestBidAmount = $.id('highestBidAmount')
  const $highestBidder = $.id('highestBidder')
  const $bidHistory = $.id('bidHistory')
  const $previousBidList = $.id('previousBidList')
  const $highestBidLabel = $.id('highestBidLabel')

  const $settlementSection = $.id('settlementSection')
  const $settlementSectionContent = $.id('settlementSectionContent')
  const $submitSettlement = $.id('submitSettlement')
  const $settlementSectionError = $.id('settlementSectionError')
  const $settlementSectionLoading = $.id('settlementSectionLoading')
  const $settlementSectionLoadingMessage = $.id('settlementSectionLoadingMessage')

  const $question = $.id('question')
  const $answer = $.id('answer')
  const $answerX = $.id('answerX')
  const $answerContent = $.id('answerContent')

  const $biddingHelp = $.id('biddingHelp')

  let stopActiveCountdownInterval = () => {}
  let setMinBid = false
  async function updateBidInfo(signer, steviepAuction, uniswapV2) {
    const bidRequest = rawSteviepAuction.queryFilter(bidFilter).then(rawBids =>
      Promise.all(
        rawBids.map(
          async e => ({
            bidder: e.args.bidder,
            bidderDisplay: await formatAddr(e.args.bidder),
            amount: ethVal(e.args.amount),
            auctionId: bnToN(e.args.auctionId),
            timestamp: bnToN(e.args.timestamp),
          })
        )
      )
    )

    const signerAddr = await signer.getAddress()
    const [
      highestBid,
      auction,
      auctionEndTime,
      isActive,
      blockNumber,
      formattedAddr,
      unsortedBidsMade,
      connectedBalance,
      ethUsd
    ] = await Promise.all([
      steviepAuction.auctionIdToHighestBid(AUCTION_ID),
      steviepAuction.auctionIdToAuction(AUCTION_ID),
      steviepAuction.auctionEndTime(AUCTION_ID),
      steviepAuction.isActive(AUCTION_ID),
      provider.provider.getBlockNumber(),
      formatAddr(signerAddr, provider),
      bidRequest,
      provider.getETHBalance(signerAddr),
      getEthUsd(uniswapV2)
    ])

    const hasBid = !!bnToN(highestBid.timestamp)
    const blockTimestamp = (await provider.provider.getBlock(blockNumber)).timestamp
    const timeDiff = Date.now() - blockTimestamp*1000

    $lastUpdated.innerHTML = `Local timestamp: ${new Date()} <br>Block timestamp: ${new Date(blockTimestamp*1000)}<br>[Block: ${blockNumber}]`
    if (isENS(formattedAddr)) {
      $connectedAs1.innerHTML = formattedAddr
    }
    $connectedAs2.innerHTML = `<a href="https://etherscan.io/address/${signerAddr}" target="_blank" class="address">${signerAddr}</a>`
    $connectedBalance.innerHTML = `Balance: ${ethVal(connectedBalance)} ETH`

    const bidsMade = unsortedBidsMade.sort((a,b) => b.timestamp - a.timestamp)


    if (!hasBid) {
      hide($bidHistory)
      unhide($makeBidSection)

      if (!setMinBid) $newBidAmount.value = formatMinBid(ethVal(auction.minBid))

    } else if (isActive) {
      unhide($makeBidSection)
      unhide($timeLeftSection)
      unhide($highestBidSection)
      unhide($activeBidSection)
      unhide($bidHistory)
      if (!setMinBid) $newBidAmount.value = formatMinBid(ethVal(highestBid.amount) * (1 + auction.bidIncreaseBps/10000))

      const bidAmount = ethVal(highestBid.amount)
      $highestBidAmount.innerHTML = `${bidAmount} ETH <div class="bidUSD">(~$${(bidAmount * ethUsd).toFixed(2)})</div>`
      $highestBidder.innerHTML = `<a href="https://etherscan.io/address/${highestBid.bidder}" target="_blank" class="address">${await formatAddr(highestBid.bidder, provider, false)}</a>`


      stopActiveCountdownInterval()
      const timeLeft = bnToN(auctionEndTime)*1000 - Date.now()
      stopActiveCountdownInterval = triggerTimer(timeLeft, $timeLeft)
      if (timeLeft < 120000) $timeDiff.innerHTML = `*Your web browser is <br>~${Math.abs(timeDiff/1000)} seconds ${timeDiff < 0 ? 'behind' : 'ahead of'} <br>the blockchain`


    } else if (!isActive && !auction.isSettled) {
      hide($makeBidSection)
      hide($timeLeftSection)
      unhide($highestBidSection)
      unhide($settlementSection)
      unhide($activeBidSection)
      unhide($bidHistory)

      $highestBidLabel.innerHTML = 'WINNING BID'

      $highestBidAmount.innerHTML = ethVal(highestBid.amount) + ' ETH'
      $highestBidder.innerHTML = `<a href="https://etherscan.io/address/${highestBid.bidder}" target="_blank" class="address">${await formatAddr(highestBid.bidder, provider, false)}</a>`



    } else if (!isActive && auction.isSettled) {
      hide($makeBidSection)
      hide($timeLeftSection)
      hide($settlementSection)
      unhide($highestBidSection)
      unhide($activeBidSection)
      unhide($bidHistory)

      $highestBidLabel.innerHTML = 'WINNING BID'
      $highestBidAmount.innerHTML = ethVal(highestBid.amount) + ' ETH'
      $highestBidder.innerHTML = `<a href="https://etherscan.io/address/${highestBid.bidder}" target="_blank" class="address">${await formatAddr(highestBid.bidder, provider, false)}</a>`

    }
    setMinBid = true

    if (bidsMade.length) {
      $previousBidList.innerHTML = bidsMade.map(bid => {
        const bidAmount = Number(bid.amount.toFixed(14))
        const bidAmountUSD = (bidAmount * ethUsd).toFixed(2)
        const bidAmountPretty = String(bidAmount).includes('.') ? bidAmount : bidAmount.toFixed(1)
        return `
          <li class="bidHistoryItem">
            <div class="bidHistoryRow">
              <div>BID: ${bidAmountPretty} ETH (~$${bidAmountUSD})</div>
              <div>
                <a href="https://etherscan.io/address/${bid.bidder}" target="_blank" class="address">${bid.bidderDisplay}</a>
              </div>
            </div>
            <div>${new Date(bid.timestamp * 1000)}</div>
          </li>
        `
      }).join('')
    }


    const formatTime = (amt, measurement) => Math.round(amt*100)/100 + ' ' + (amt === 1 ? measurement : measurement + 's')
    const formatDuration = duration =>
      duration < 60 ? formatTime(duration, 'second') :
      duration < 3600 ? formatTime(duration / 60, 'minute') :
      duration <= 86400 ? formatTime(duration / 3600, 'hour') :
      formatTime(duration / 86400, 'day')


    const auctionLength = formatDuration(auction.duration)
    const reservePrice = ethVal(auction.minBid)
    const bidExtension = formatDuration(bnToN(auction.bidTimeExtension))
    const bidIncrease = bnToN(auction.bidIncreaseBps) / 100 + '%'

    $answerContent.innerHTML = `
      <ul>
        <li>This auction has ${reservePrice ? `a reserve price of ${reservePrice} ETH` : 'no reserve price'}.</li>
        <li>Once the first bid is made, the auction will last ${auctionLength}.</li>
        <li>All bids made in the final ${bidExtension} will extend the auction.</li>
        <li>All bids must be ${bidIncrease} higher than the previous bid.</li>
        <li>Bids cannot be withdrawn once they are made.</li>
        <li>All bids must be made in ETH.</li>
      </ul>
    `
  }

  provider.onConnect(async () => {
    const steviepAuction = await provider.contract(STEVIEP_AUCTION, auctionABI)
    const uniswapV2 = await provider.contract(UNISWAP_V2, uniswapV2ABI)
    const rawSteviepAuction = provider.rawContract(STEVIEP_AUCTION, auctionABI)

    setRunInterval(() => updateBidInfo(provider.signer, steviepAuction, uniswapV2), 3000)


    $submitBid.onclick = async () => {
      hide($bidSectionContent)
      hide($biddingHelp)
      unhide($bidSectionLoading)
      $bidSectionError.innerHTML = ''
      $bidSectionLoadingMessage.innerHTML = 'Submitting...'

      try {
        const [highestBid, auction] = await Promise.all([
          steviepAuction.auctionIdToHighestBid(AUCTION_ID),
          steviepAuction.auctionIdToAuction(AUCTION_ID),
        ])

        const minBid = highestBid.amount
          ? ethVal(highestBid.amount) * (1 + auction.bidIncreaseBps/10000)
          : ethVal(auction.minBid)

        if ($newBidAmount.value < minBid) {
          throw new Error(`Bid must be at least ${minBid} ETH`)
        }
        const tx = await rawSteviepAuction.connect(provider.signer).bid(AUCTION_ID, ethValue($newBidAmount.value))

        $bidSectionLoadingMessage.innerHTML = `TX Pending. <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">View on etherscan</a>`

        const txReciept1 = await tx.wait(1)

        setMinBid = false
        updateBidInfo(provider.signer, steviepAuction, uniswapV2)

        unhide($bidSectionContent)
        unhide($biddingHelp)
        hide($bidSectionLoading)

      } catch (e) {
        unhide($bidSectionContent)
        hide($bidSectionLoading)
        if (e.data) {
          $bidSectionError.innerHTML = e.data.message
        } else {
          $bidSectionError.innerHTML = e.message
        }
      }
    }


    $submitSettlement.onclick = async () => {
      hide($settlementSectionContent)
      unhide($settlementSectionLoading)
      $settlementSectionError.innerHTML = ''
      $settlementSectionLoadingMessage.innerHTML = 'Submitting...'

      try {
        const tx = await rawSteviepAuction.connect(provider.signer).settle(AUCTION_ID)

        $settlementSectionLoadingMessage.innerHTML = `TX Pending. <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">View on etherscan</a>`

        const txReciept1 = await tx.wait(1)

        updateBidInfo(provider.signer, steviepAuction, uniswapV2)

        unhide($settlementSectionContent)
        hide($settlementSectionLoading)

      } catch (e) {
        unhide($settlementSectionContent)
        hide($settlementSectionLoading)
        if (e.data) {
          $settlementSectionError.innerHTML = e.data.message
        } else {
          $settlementSectionError.innerHTML = e.message
        }
      }
    }
  })


  let showingAnswer = false
  $question.onclick = () => {
    showingAnswer = true
    hide($question)
    unhide($answer)
  }

  $answerX.onclick = () => {
    showingAnswer = false
    unhide($question)
    hide($answer)
  }

  async function getEthUsd(uniswapV2) {
    const decimals = 2
    const { _reserve0, _reserve1 } = await uniswapV2.getReserves()
    return _reserve0.mul(1000000000000).mul(10**decimals).div(_reserve1).toNumber() / 10**decimals
  }




  function formatMinBid(amt) {
    return Math.ceil(amt * 1000) / 1000
  }

  function isENS(ens) {
    return ens.slice(-4) === '.eth'
  }
  async function formatAddr(addr, provider, truncate=true) {
    try {
      const ens = await provider.getENS(addr)
      if (ens.slice(-4) === '.eth') {
        return ens.length > 10
          ? ens.slice(0, 10) + '...'
          : ens
      } else {
        return truncate ? truncateAddr(addr) : addr
      }
    } catch (e) {
      return truncate ? truncateAddr(addr) : addr
    }
  }


  function unhide(element) {
    $(element, 'display', '')
  }

  function hide(element) {
    $(element, 'display', 'none')
  }

  function setRunInterval(fn, ms, i=0) {
    const run = () => {
      fn(i)
      i++
    }

    run()

    let isCleared = false

    let interval = setInterval(run, ms)

    const newInterval = (ms) => {
      if (isCleared) return
      clearInterval(interval)
      interval = setInterval(run, ms)
    }

    const stopInterval = () => {
      if (!isCleared) {
        clearInterval(interval)
        isCleared = true
      }
    }
    return stopInterval
  }

  function triggerTimer(timeLeft, $elem) {
    const with0 = x => x < 10 ? '0' + Math.floor(x) : Math.floor(x)
    let timeLeftCounter = timeLeft
    return setRunInterval(() => {
      timeLeftCounter = Math.max(timeLeftCounter - 1000, 0)
      const days = timeLeftCounter / (24*60*60*1000)
      const hours = 24 * (days%1)
      const minutes = 60 * (hours%1)
      const seconds = Math.floor(60 * (minutes%1))
      const ms = Math.floor(timeLeftCounter % 1000 / 100) % 10

      $elem.innerHTML = `${Math.floor(days)}:${with0(hours)}:${with0(minutes)}:${with0(seconds)}`
    }, 1000)
  }

</script>



<script type="text/javascript">
  var hours = new Date().getHours();
  if (hours <= 5 || hours >= 22) document.body.className = 'nightmode';
</script>
</html>